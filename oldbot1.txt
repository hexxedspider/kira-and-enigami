##
## HEY
## YES YOU
## THIS IS THE OLD BOT FOR KIRABITER, IT HAD A LOT OF BUGS THAT SIMPLY TOOK TOO LONG TO FIX, SO I STARTED AGAIN
## THE bot1.py IS THE NEW OLD
##

import discord
from discord import ButtonStyle, app_commands
from discord.ext import commands, tasks
from dotenv import load_dotenv
import os
import random
import aiohttp
import asyncpraw 
from discord.ui import View, Button
from collections import defaultdict
import re
from tinydb import TinyDB, Query
from datetime import datetime, timedelta
import json
import time
import asyncio
from types import SimpleNamespace
import dateutil.parser
import threading
import pytz
import ast
import operator

#db.json stores shit
db = TinyDB("db.json")
balances_table = db.table("balances")
marriages_table = db.table("marriages")
pending_proposals = {} 
vows_table = db.table("vows")
users = Query()
investments_table = db.table("investments")
User = Query()
db = TinyDB('bingo_db.json')
Bingo = Query()

# actually grabbing the token from the .env file
load_dotenv()
BOT1 = os.getenv("BOT1")
OWNID = os.getenv("OWNID")
FM_API = os.getenv("FM_API")
FM_USERNAME = os.getenv("FM_USERNAME")
REPORT_CHANNEL_ID = os.getenv("REPORT_CHANNEL_ID")
REDDIT_CLIENT_ID = os.getenv("REDDIT_CLIENT_ID")
REDDIT_CLIENT_SECRET = os.getenv("REDDIT_CLIENT_SECRET")
REDDIT_USER_AGENT = os.getenv("REDDIT_USER_AGENT")
REPORT_CHANNEL_ID = os.getenv("REPORT_CHANNEL_ID")

# intents are basic permissions that the bot needs to function
# e.g. intents.message_content allows the bot to read the content of messages
intents = discord.Intents.default()
intents.message_content = True  # Required to read message content

# prefix, just like / but not.
bot = commands.Bot(command_prefix=".", intents=intents, help_command=None)

bot.heist_active = False
bot.heist_players = []
heist_cooldowns = {}



# Path to your log file
LOG_FILE = "command_log_1.txt"

def log_command(ctx):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    username = f"{ctx.author.name}"
    command_used = ctx.message.content
    guild_name = ctx.guild.name if ctx.guild else "DM"

    log_line = f"[kirabiter] [{timestamp}] [{guild_name}] {username}: {command_used}\n"
    with open(LOG_FILE, "a", encoding="utf-8") as f:
        f.write(log_line)

@bot.event
async def on_command(ctx):
    log_command(ctx)

BALANCE_FILE = os.path.join("db.json")

if not os.path.exists(BALANCE_FILE) or os.path.getsize(BALANCE_FILE) == 0:
    with open(BALANCE_FILE, "w") as f:
        json.dump({}, f, indent=4)
    balances = {}

investments = {}

bingo_active = False

# In-memory cooldown tracker, change to db.json later or something
heist_cooldowns = {}  # {user_id: datetime}

def get_full_balance(user_id: str):
    user_data = balances.get(user_id)

    if isinstance(user_data, dict) and "wallet" in user_data and "bank" in user_data:
        return user_data
    else:
        # Convert old format (int balance only) to full format
        initial_wallet = user_data if isinstance(user_data, int) else 100
        balances[user_id] = {"wallet": max(initial_wallet, 0), "bank": 0}
        with open(BALANCE_FILE, "w") as f:
            json.dump(balances, f, indent=4)
        return balances[user_id]

def set_full_balance(user_id: str, wallet: int, bank: int):
    balances[user_id] = {"wallet": max(wallet, 0), "bank": max(bank, 0)}
    with open(BALANCE_FILE, "w") as f:
        json.dump(balances, f, indent=4)

#load shop items cause it didnt before
SHOP_FILE = "shop_items.json"

try:
    with open(SHOP_FILE, "r") as f:
        shop_items = json.load(f)
except FileNotFoundError:
    shop_items = {}

async def update_balance(user_id: int, amount: int, ctx: commands.Context = None):
    user_key = str(user_id)
    # Ensure user data exists
    if user_key not in balances:
        balances[user_key] = {"wallet": 100, "bank": 0}

    current = balances[user_key].get("wallet", 100)
    new_balance = max(current + amount, 0)
    balances[user_key]["wallet"] = new_balance

    # Save balances to file
    with open(BALANCE_FILE, "w") as f:
        json.dump(balances, f, indent=4)

    # Assign bankrupt role if balance just dropped to zero
    if current > 0 and new_balance == 0 and ctx is not None:
        await assign_bankrupt_role(ctx, user_id)

async def assign_bankrupt_role(ctx, user_id):
    guild = ctx.guild
    member = guild.get_member(user_id)
    if member is None:
        return

    # Find or create the role
    role_name = "Once Bankrupt"
    role = discord.utils.get(guild.roles, name=role_name)
    if role is None:
        try:
            role = await guild.create_role(name=role_name)
        except discord.Forbidden:
            await ctx.send("I don't have permission to create roles.")
            return

    # Assign the role
    if role not in member.roles:
        try:
            await member.add_roles(role)
            await ctx.send(f"{member.mention} has gone bankrupt and earned the **{role_name}** role.")
        except discord.Forbidden:
            await ctx.send("I can't assign roles. Please check my permissions.")

class HelpView(discord.ui.View):
    def __init__(self, embeds):
        super().__init__(timeout=60)  # Timeout after 60 seconds
        self.embeds = embeds
        self.current = 0

    async def update_message(self, interaction):
        await interaction.response.edit_message(embed=self.embeds[self.current], view=self)

    @discord.ui.button(label="Next", style=discord.ButtonStyle.primary)
    async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.current = (self.current + 1) % len(self.embeds)
        await self.update_message(interaction)

    @discord.ui.button(label="Previous", style=discord.ButtonStyle.primary)
    async def previous(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.current = (self.current - 1) % len(self.embeds)
        await self.update_message(interaction)

@bot.command()
async def invenilink(ctx):
    try:
        await ctx.author.send("[Link here.](https://discord.com/oauth2/authorize?client_id=1380716495767605429&permissions=8&integion_type=0&scope=bot)")
    except discord.Forbidden:
        error = await ctx.send("I couldn't DM you. Please check your privacy settings.")
        await error.delete(delay=5)

    await ctx.message.delete(delay=0.1)

class HelpView(discord.ui.View):
    def __init__(self, embeds):
        super().__init__(timeout=60)  # Timeout after 60 seconds
        self.embeds = embeds
        self.current = 0

    async def update_message(self, interaction):
        await interaction.response.edit_message(embed=self.embeds[self.current], view=self)

    @discord.ui.button(label="Next", style=discord.ButtonStyle.primary)
    async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.current = (self.current + 1) % len(self.embeds)
        await self.update_message(interaction)

    @discord.ui.button(label="Previous", style=discord.ButtonStyle.primary)
    async def previous(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.current = (self.current - 1) % len(self.embeds)
        await self.update_message(interaction)

# embed.add_field(name="", value="", inline=True)
@bot.command()
async def help(ctx):
    embed1 = discord.Embed(
        title="Help Page 1",
        description="Fun & Info Commands",
        color=discord.Color.blurple()
    )
    embed1 = discord.Embed(
    title="Help Page 1",
    description="Reply Commands - Replies to 'example' whenever it's messaged.",
    color=discord.Color.blurple()
)
    embed1.add_field(name="'peak'", value="peak", inline=True)
    embed1.add_field(name="'real'", value="real", inline=True)
    embed1.add_field(name="'kirabiter'", value="Replies with a random greeting to the mention of it's name.", inline=True)
    embed1.add_field(name="'...end it...'", value="Replies with a random sentence encouraging you.", inline=True)
    embed1.set_footer(text=f"This menu disables in 60 seconds.")
    embed2 = discord.Embed(
    title="Help Page 2",
    description="Basic Commands",
    color=discord.Color.blurple()
)
    embed2.set_footer(text=f"This menu disables in 60 seconds.")
    embed2.add_field(name=".die", value="Roll a 6 sided die.", inline=True)
    embed2.add_field(name=".cf", value="Flip a coin.", inline=True)
    embed2.add_field(name=".eightball", value="Ask the Eightball a question.", inline=True)
    embed2.add_field(name=".sava", value="Grabs the server's icon/avatar.", inline=True)
    embed2.add_field(name=".define", value="Get the definition of a term from Urban Dictionary.", inline=True)
    embed2.add_field(name=".ava", value="Grab the icon/avatar of a user (mention person).", inline=True)

    embed3 = discord.Embed(
    title="Help Page 3",
    description="Fun & Info Commands",
    color=discord.Color.blurple()
)
    embed3.set_footer(text=f"This menu disables in 60 seconds.")
    embed3.add_field(name=".userinfo", value="Get info about a user.", inline=True)
    embed3.add_field(name=".serverinfo", value="Get info about the server.", inline=True)
    embed3.add_field(name=".uinfcmd", value="This will send an embed with what 'userinfo' will return.", inline=True)
    embed3.add_field(name=".dminfo", value="Returns a message with the info of your user, but tweaked to work in DMs.", inline=True)
    embed3.add_field(name=".rps", value="Play rock paper scissors against the bot, also pairs with .rpsstats. Rewards money.", inline=True)
    embed3.add_field(name=".red", value="Fetches media from a subreddit. Example: .red aww image/gif - .red [nsfw subreddit] image/gif true.", inline=True)

    embed4 = discord.Embed(
    title="Help Page 4",
    description="Fun & Info Commands",
    color=discord.Color.blurple()
)
    embed4.set_footer(text=f"This menu disables in 60 seconds.")
    embed4.add_field(name=".balance", value="Shows you the current amount of currency you have.", inline=True)
    embed4.add_field(name=".gamble", value="50 percent chance of either winning or losing, add the amount you'd like to bet after typing .gamble.", inline=True)
    embed4.add_field(name=".daily", value="Gives a daily bonus of 100.", inline=True)
    embed4.add_field(name=".say", value="Forces the bot to say your message in the same channel, and it deletes your original message.", inline=True)
    embed4.add_field(name=".github", value="Sends a link to the bot's github (all three are in the repo').", inline=True)
    embed4.add_field(name=".helpme", value="Returns a random image (horror or liminal).")

    embed5 = discord.Embed(
    title="Help Page 5",
    description="Fun & Info Commands",
    color=discord.Color.blurple()
)
    embed5.set_footer(text=f"This menu disables in 60 seconds.")
    embed5.add_field(name=".shop", value="Sends an embed with the current shop.", inline=True)
    embed5.add_field(name=".buy", value="Buy something from the shop.", inline=True)
    embed5.add_field(name=".inventory", value="Shows off your inventory of tags.", inline=True)
    embed5.add_field(name=".sell", value="Sells an item you have.", inline=True)
    embed5.add_field(name=".cfmilestones", value="Shows milestones of coinflips and the attached roles.", inline=True)
    embed5.add_field(name=".cfstats", value="Shows your coinflip stats.", inline=True)

    embed6 = discord.Embed(
    title="Help Page 6",
    description="Fun & Info Commands",
    color=discord.Color.blurple()
)# embed6.add_field(name=".", value="", inline=True)
    
    embed6.set_footer(text=f"This menu disables in 60 seconds.")
    embed6.add_field(name=".bet", value="Starts a coinflip challenge for a specified amount of money.", inline=True)
    embed6.add_field(name=".acceptbet", value="Accepts a coinflip challenge from another user.", inline=True)
    embed6.add_field(name=".bailout", value="Only able to be used if you have no money, 12h cooldown, awards $50.", inline=True)
    embed6.add_field(name=".timeinvest", value="Shows how much longer until your investment is over.", inline=True)
    embed6.add_field(name=".blackjack", value="Bet a amount of your choosing and play blackjack against the bot.", inline=True)
    embed6.add_field(name=".rob", value="5 minute cooldown, try to rob a person of money. 20 percent chance of being successful, lose money if not. ", inline=True)

    embed7 = discord.Embed(
    title="Help Page 7",
    description="Fun & Info Commands",
    color=discord.Color.blurple()
)
    embed7.set_footer(text=f"This menu disables in 60 seconds.")
    embed7.add_field(name=".clear", value="Clears bot's messages. Defaults to 5, can change with .clear 'number'", inline=True)
    embed7.add_field(name=".cleardm", value="Clears bot's messages, but this time in DMs. Defaults to 5, can change with .cleardm 'number'", inline=True)
    embed7.add_field(name=".kiratest", value="Sends an invite to the kirabiter test server.")
    embed7.add_field(name=".deposit", value="Put money into your bank to protect your money from being robbed.")
    embed7.add_field(name=".withdraw", value="Take money out the bank to spend on games, buy from .shop, or other things.")
    embed7.add_field(name=".invest", value="Wait 10 minutes to get a 1.2x return on the money you put in. Stacks quickly, but needs a person to run, unlike the passive interest in the bank.")

    embed8 = discord.Embed(
        title="Help Page 8",
        description="Fun & Info Commands",
        color=discord.Color.blurple()
)
    embed8.set_footer(text=f"This menu disables in 60 seconds.")
    embed8.add_field(name=".report", value="Sends a message to a specified channel.")
    embed8.add_field(name=".kbsc", value="Directly download this bot's source code (may be broken, python file only).")
    embed8.add_field(name=".heist", value="Start a heist! Explained upon use, along with the Heist Guardian role.", inline=True)
    embed8.add_field(name=".joinheist", value="Join the ongoing heist.", inline=True)
    embed8.add_field(name=".leaveheist", value="Leave the heist you're in.", inline=True)
    embed8.add_field(name=".heistcrew", value="Shows your current crew, containing highest role, money, pfp, and name.", inline=True)

    embed9 = discord.Embed(
        title="Help Page 9",
        description="Fun & Info Commands",
        color=discord.Color.blurple()
)
    embed9.set_footer(text=f"This menu disables in 60 seconds.")
    embed9.add_field(name=".taginfo", value="Shows info about a role you have.", inline=True)
    embed9.add_field(name=".compliment", value="Sends a random compliment.", inline=True)
    embed9.add_field(name=".remindme", value="Sends a reminder of your choosing.", inline=True)
    embed9.add_field(name=".event", value="Shows the current event.", inline=True)
    embed9.add_field(name=".roast", value="Sends a random roast.", inline=True)
    embed9.add_field(name=".slots", value="Play slots. Simple.", inline=True)

    embed10 = discord.Embed(
    title="Help Page 10",
    description="Game & Meme Commands",
    color=discord.Color.blurple()
)
    embed10.set_footer(text=f"This menu disables in 60 seconds.")

    embed10.add_field(name=".hangman", value="Start a game of hangman. Guess with `.guess <letter>`.", inline=True)
    embed10.add_field(name=".guess", value="Submit a letter guess for your hangman game.", inline=True)
    embed10.add_field(name=".tictactoe", value="Challenge someone to a game of Tic-Tac-Toe. Mention them after typing .tictactoe.", inline=True)
    embed10.add_field(name=".place", value="Place your X or O in the Tic-Tac-Toe board.", inline=True)
    embed10.add_field(name=".owoify", value="Converts your text into cute OwO speak.", inline=True)
    embed10.add_field(name=".mock", value="Reformats your text into a mocking tone.", inline=True)

    embed11 = discord.Embed(
        title="Help - Commands 1 to 6",
        description="Here are some of the bot commands:",
        color=discord.Color.blue()
)
    embed11.add_field(name=".time", value="Show current time in your timezone.", inline=False)
    embed11.add_field(name=".timezone", value="Set or view your timezone.", inline=False)
    embed11.add_field(name=".lyrics", value="Get lyrics of a song.", inline=False)
    embed11.add_field(name=".calc", value="Calculate a math expression.", inline=False)
    embed11.add_field(name=".kill", value="Rather line along killing someone.", inline=False)
    embed11.add_field(name=".connect4", value="Play Connect4 against someone.", inline=False)
    
    embed12 = discord.Embed(
        title="Help - Commands 7 to 12",
        description="More bot commands:",
        color=discord.Color.blue()
    )
    embed12.add_field(name=".marry", value="Marry another user.", inline=False)
    embed12.add_field(name=".divorce", value="Divorce your spouse.", inline=False)
    embed12.add_field(name=".marriages", value="View all marriages.", inline=False)
    embed12.add_field(name=".propose", value="Propose marriage to someone.", inline=False)
    
    view = HelpView([embed1, embed2, embed3, embed4, embed5, embed6, embed7, embed8, embed9, embed10, embed11, embed12])
    await ctx.send(embed=embed1, view=view)

@bot.command()
async def die(ctx):
    roll = random.randint(1, 6)
    await ctx.send(f"You rolled a {roll}!")

@bot.command()
async def uinfcmd(ctx):
    embed = discord.Embed(
        title="User Info Command",
        description="This command provides detailed information about a user.",
        color=discord.Color.blue()
    )
    
    embed.add_field(name="Username and Discriminator.", value="Exactly what it says, discrim will always return a 0 as they don't use it anymore, only on bots and unused accounts.", inline=False)
    embed.add_field(name="ID", value="Grants the userid, which typically isn't useful.", inline=False)
    embed.add_field(name="Top Role", value="The highest role someone has, for non-staff it'll typically be a color role.", inline=False)
    embed.add_field(name="Joined server and discord.", value="Exactly as it says.", inline=False)

    embed.set_footer(text=f"{ctx.author}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
    
    await ctx.send(embed=embed)
@bot.command()
async def dminfo(ctx, member: discord.Member = None):
    member = member or ctx.author

    embed = discord.Embed(
        title=f"User Info: {member}",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=member.avatar.url if member.avatar else None)
    embed.add_field(name="Username", value=member.name, inline=True)
    embed.add_field(name="Discriminator", value=member.discriminator, inline=True)
    embed.add_field(name="ID", value=member.id, inline=False)
    embed.add_field(name="Joined Discord", value=member.created_at.strftime("%b %d, %Y"), inline=False)

    await ctx.send(embed=embed)


@bot.command()
async def userinfo(ctx, member: discord.Member = None):
    member = member or ctx.author  # Default to the person who ran the command

    embed = discord.Embed(
        title=f"User Info: {member}",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=member.avatar.url if member.avatar else None)
    embed.add_field(name="Username", value=member.name, inline=True)
    embed.add_field(name="Discriminator", value=member.discriminator, inline=True)
    embed.add_field(name="ID", value=member.id, inline=False)
    embed.add_field(name="Top Role", value=member.top_role.mention, inline=True)
    embed.add_field(name="Joined Server", value=member.joined_at.strftime("%b %d, %Y"), inline=False)
    embed.add_field(name="Joined Discord", value=member.created_at.strftime("%b %d, %Y"), inline=False)

    await ctx.send(embed=embed)

@bot.event
async def on_message(message):
    if message.author == bot.user:
        return

    # Normalize: lowercase, remove punctuation, strip extra spaces
    msg_content = re.sub(r'[^\w\s]', '', message.content.lower()).strip()

    if msg_content == "real":
        await message.reply("real")

    elif msg_content == "peak":
        await message.reply("peak")

    elif "ending it" in msg_content:
        responses = [
            "DO IT, NO BALLS", "do it", "waiting for you to do it",
            "do it already", "do it, pussy", "do it, you won't",
            "do it, you won't do it", "do it, you won't do it, pussy"
        ]
        await message.reply(random.choice(responses))

    # If the bot is mentioned by name
    bot_names = [bot.user.name.lower()]
    if message.guild:
        member = message.guild.get_member(bot.user.id)
        if member and member.nick:
            bot_names.append(member.nick.lower())

    if any(name in msg_content for name in bot_names):
        greetings = [
            "wsp?", "wsp", "hey", "helloo", "hi", "yo", "LEAVE ME ALONE", "SHUT THE FUCK UP", "don't bother me",
            "what you trynna get into?", "leave me alone", "yea mane?", "don't speak my name",
            "you sound better when you're not talking", "please be quiet", "god you sound obnoxious", "yes honey?", "yes my darling?",
            "dont take my compliments to heart, im forced to say it.", "trust me, i dont want to talk to you", "you in specific piss me off",
            "just came back from coolville, they ain't know you", "want to go down the slide with me?", "want to go on the swings? the playground's empty.",
            "just came back from coolville, they said you're the mayor", "lowkey dont know what im doing give me a sec", ".help is NOT my name, try again",
            "hold on im shoving jelly beans up my ass", "cant talk, im at the doctors, but tell me why they said i need to stop letting people finish in me ??"
            "cant talk rn, to make a long story short, im being chased for putting barbeque sauce on random people",
            "im at the dentist rn but they said i need to stop doing oral ??", "the aliens are coming, hide", "im coming, hide", "how the fuck does this thing work?"
            "i cnat fiind my glases, 1 sec", "i difnt fnid my glasess", "holy fuck shut up", "do you ever be quiet?", "will you die if you stop talking?", "yeah?", "what?",
            "i felt lonely for a long time, but then i bought a jetski", "Kirabiter, coming to a server near you soon!", "this is a secret!", "use .nsfw for a secret :P",
            "ay im at the chiropracters rn, but she told me i have to stop taking backshots, give me a sec", "SOMEONE HELP ME", "ew"
        ]
        await message.reply(random.choice(greetings))

    await bot.process_commands(message)

@bot.command()
async def eightball(ctx, *, question: str):
    responses = [
        "Yes", "No", "maybe ?", "Definitely", "Absolutely not, even a cracked out person would agree with me", 
        "Ask again later, I'm jacking it.", "Yeah, probably", "Unlikely", "idk gang"
    ]
    await ctx.send(f"ðŸŽ± Question: {question}\nAnswer: {random.choice(responses)}")

@bot.command()
async def cf(ctx):
    await ctx.send(f"The coin landed on **{random.choice(['Heads', 'Tails'])}**!")

@bot.command()
async def serverinfo(ctx):
    guild = ctx.guild
    embed = discord.Embed(
        title=f"{guild.name}",
        description="Server Information",
        color=discord.Color.dark_red()
    )
    embed.set_thumbnail(url=guild.icon.url if guild.icon else None)
    embed.add_field(name="Owner", value=guild.owner, inline=True)
    embed.add_field(name="Members", value=guild.member_count, inline=True)
    embed.add_field(name="Created On", value=guild.created_at.strftime("%b %d, %Y"), inline=True)
    await ctx.send(embed=embed)

@bot.command()
async def ava(ctx, member: discord.Member = None):
    member = member or ctx.author
    avatar_url = member.avatar.url if member.avatar else "No avatar"
    await ctx.send(f"{member.mention}'s avatar: {avatar_url}")

@bot.command()
async def define(ctx, *, term: str):
    """Fetches the definition of a term from Urban Dictionary."""
    url = f"https://api.urbandictionary.com/v0/define?term={term}"

    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            if resp.status != 200:
                await ctx.send(f"Sorry, couldn't fetch definitions for **{term}**.")
                return
            data = await resp.json()

    if not data["list"]:
        await ctx.send(f"No results found for **{term}** on Urban Dictionary.")
        return

    # Take the top definition
    top_def = data["list"][0]
    definition = top_def["definition"]
    example = top_def.get("example", "")
    author = top_def.get("author", "Unknown")

    # Urban Dictionary definitions often contain [brackets], remove or replace them
    import re
    clean_def = re.sub(r"\[|\]", "", definition)
    clean_example = re.sub(r"\[|\]", "", example)

    embed = discord.Embed(
        title=f"Urban Dictionary: {term}",
        description=clean_def,
        color=discord.Color.purple()
    )
    if clean_example:
        embed.add_field(name="Example", value=clean_example, inline=False)
    embed.set_footer(text=f"Defined by {author}")

    await ctx.send(embed=embed)

reddit = None  # global placeholder

sent_posts_cache = {}  # {subreddit: set(post_ids)}

def filter_posts(posts, fmt):
    if fmt == "image":
        return [
            post for post in posts
            if hasattr(post, "url") and post.url.lower().endswith((".jpg", ".jpeg", ".png"))
        ]
    elif fmt == "video":
        return [
            post for post in posts
            if hasattr(post, "url") and (
                post.url.lower().endswith((".mp4", ".webm"))
                or (
                    "v.redd.it" in post.url.lower()
                    and not post.url.lower().endswith((".jpg", ".jpeg", ".png", ".gif"))
                )
            )
        ]
    else:  # any
        return [
            post for post in posts
            if hasattr(post, "url") and (
                post.url.lower().endswith((".jpg", ".jpeg", ".png", ".gif", ".mp4", ".webm", ".gifv"))
                or "v.redd.it" in post.url.lower()
            )
        ]

async def send_reddit_media(ctx, subreddit: str = "all", fmt: str = "any"):
    if reddit is None:
        await ctx.send("Reddit client not ready yet.")
        return

    try:
        sub = await reddit.subreddit(subreddit, fetch=True)
        posts = [post async for post in sub.hot(limit=50)]
    except Exception as e:
        await ctx.send(f"Could not fetch subreddit: {e}")
        return

    is_nsfw_channel = getattr(ctx.channel, "is_nsfw", lambda: False)()
    is_dm = isinstance(ctx.channel, discord.DMChannel)
    if getattr(sub, "over18", False) and not (is_nsfw_channel or is_dm):
        await ctx.send("NSFW content can only be sent in NSFW channels or DMs.")
        return

    # Filter by format
    media_posts = filter_posts(posts, fmt)

    # Caching: skip posts already sent
    cache = sent_posts_cache.setdefault(subreddit, set())
    unsent_posts = [post for post in media_posts if post.id not in cache]

    if not unsent_posts:
        await ctx.send("No new matching media found in that subreddit.")
        return

    post = random.choice(unsent_posts)
    cache.add(post.id)
    # Optional: limit cache size
    if len(cache) > 200:
        cache.pop()

    await ctx.send(post.url)

@bot.command()
async def red(ctx, subreddit: str = "all"):
    await send_reddit_media(ctx, subreddit)

@bot.command()
async def sava(ctx, *, user: discord.User = None):
    user = user or ctx.author

    pfp_url = user.display_avatar.url

    embed = discord.Embed(
        title=f"{user.display_name}'s Profile Picture",
        color=discord.Color.blue()
    )
    embed.set_image(url=pfp_url)

    await ctx.send(embed=embed)

balances_table = db.table('balances')
User = Query()

rps_stats = defaultdict(lambda: {"wins": 0, "losses": 0, "ties": 0})

@bot.command()
async def rps(ctx):

    event = get_active_event()
    effects = event.get("effects", {})
    multiplier = effects.get("rps_multiplier", 1.0) 

    class RPSView(View):
        def __init__(self, user):
            super().__init__(timeout=30)
            self.user = user

        async def interaction_check(self, interaction: discord.Interaction) -> bool:
            if interaction.user != self.user:
                await interaction.response.send_message("This is not your game!", ephemeral=True)
                return False
            return True

        @discord.ui.button(label="Rock", style=ButtonStyle.primary)
        async def rock(self, interaction: discord.Interaction, button):
            await play_game(interaction, "rock", self.user)

        @discord.ui.button(label="Paper", style=ButtonStyle.success)
        async def paper(self, interaction: discord.Interaction, button):
            await play_game(interaction, "paper", self.user)

        @discord.ui.button(label="Scissors", style=ButtonStyle.danger)
        async def scissors(self, interaction: discord.Interaction, button):
            await play_game(interaction, "scissors", self.user)

    async def play_game(interaction, user_choice, user):
        choices = ["rock", "paper", "scissors"]
        bot_choice = random.choice(choices)

        WIN_REWARD = int(50 * multiplier)
        LOSS_PENALTY = int(25 * multiplier)
        TIE_REWARD = int(25 * multiplier)

        user_id = str(user.id)

        # Load balance data (wallet + bank)
        balance_data = get_full_balance(user_id)
        wallet = balance_data.get("wallet", 0)
        bank = balance_data.get("bank", 0)

        if user_choice == bot_choice:
            outcome = "It's a tie!"
            rps_stats[user.id]["ties"] += 1
            wallet += TIE_REWARD
            coin_change = TIE_REWARD
        elif (
            (user_choice == "rock" and bot_choice == "scissors") or
            (user_choice == "paper" and bot_choice == "rock") or
            (user_choice == "scissors" and bot_choice == "paper")
        ):
            outcome = "You won!"
            rps_stats[user.id]["wins"] += 1
            wallet += WIN_REWARD
            coin_change = WIN_REWARD
        else:
            outcome = "I win! Better luck next time."
            rps_stats[user.id]["losses"] += 1
            wallet = max(wallet - LOSS_PENALTY, 0)
            coin_change = -LOSS_PENALTY

        # Save updated wallet and bank
        set_full_balance(user_id, wallet, bank)

        stats = rps_stats[user.id]
        stats_msg = f"Wins: {stats['wins']}, Losses: {stats['losses']}, Ties: {stats['ties']}"
        coin_msg = f"You {'gained' if coin_change > 0 else 'lost'} ${abs(coin_change)}."

        await interaction.response.edit_message(
            content=(
                f"You chose **{user_choice}**.\nI chose **{bot_choice}**.\n\n"
                f"{outcome}\n\n{coin_msg}\n\nðŸ“Š **Your RPS Stats:** {stats_msg}"
            ),
            view=None
        )

    await ctx.send("Let's play Rock Paper Scissors! Choose one:", view=RPSView(ctx.author))

@bot.command()
async def rpsstats(ctx, member: discord.Member = None):
    member = member or ctx.author  # Defaults to command user
    stats = rps_stats.get(member.id)

    if not stats:
        await ctx.send(f"No RPS stats found for {member.display_name} yet.")
        return

    embed = discord.Embed(
        title=f"Rock Paper Scissors Stats for {member.display_name}",
        description=(
            f"**Wins:** {stats['wins']}\n"
            f"**Losses:** {stats['losses']}\n"
            f"**Ties:** {stats['ties']}"
        ),
        color=discord.Color.purple()
    )
    await ctx.send(embed=embed)

@bot.command()
@commands.has_permissions(kick_members=True)
async def kick(ctx, member: discord.Member, *, reason=None):
    try:
        await member.kick(reason=reason)
        await ctx.send(f"{member.display_name} has been kicked. Reason: {reason or 'No reason provided'}")
    except Exception as e:
        await ctx.send(f"Failed to kick {member.display_name}. Error: {e}")

# Ban command
@bot.command()
@commands.has_permissions(ban_members=True)
async def ban(ctx, member: discord.Member, *, reason=None):
    try:
        await member.ban(reason=reason)
        await ctx.send(f"{member.display_name} has been banned. Reason: {reason or 'No reason provided'}")
    except Exception as e:
        await ctx.send(f"Failed to ban {member.display_name}. Error: {e}")

@bot.command()
@commands.has_permissions(ban_members=True)
async def unban(ctx, *, member_name):
    banned_users = await ctx.guild.bans()
    member_name = member_name.lower()

    for ban_entry in banned_users:
        user = ban_entry.user
        if user.name.lower() == member_name or f"{user.name.lower()}#{user.discriminator}" == member_name:
            try:
                await ctx.guild.unban(user)
                await ctx.send(f"Unbanned {user.name}#{user.discriminator}")
                return
            except Exception as e:
                await ctx.send(f"Could not unban {user.name}. Error: {e}")
                return
    await ctx.send(f"User '{member_name}' not found in banned list.")

@bot.command()
@commands.has_permissions(manage_roles=True)
async def mute(ctx, member: discord.Member, *, reason=None):
    muted_role = discord.utils.get(ctx.guild.roles, name="Muted")
    if not muted_role:
        await ctx.send("'Muted' role not found! Please create one and set its permissions properly.")
        return

    if muted_role in member.roles:
        await ctx.send(f"{member.display_name} is already muted.")
        return

    try:
        await member.add_roles(muted_role, reason=reason)
        await ctx.send(f"{member.display_name} has been muted. Reason: {reason or 'No reason provided'}")
    except Exception as e:
        await ctx.send(f"Failed to mute {member.display_name}. Error: {e}")

@bot.command()
@commands.has_permissions(manage_roles=True)
async def unmute(ctx, member: discord.Member):
    muted_role = discord.utils.get(ctx.guild.roles, name="Muted")
    if not muted_role:
        await ctx.send("'Muted' role not found! Please create one and set its permissions properly.")
        return

    if muted_role not in member.roles:
        await ctx.send(f"{member.display_name} is not muted.")
        return

    try:
        await member.remove_roles(muted_role)
        await ctx.send(f"{member.display_name} has been unmuted.")
    except Exception as e:
        await ctx.send(f"Failed to unmute {member.display_name}. Error: {e}")

@bot.command()
@commands.has_permissions(manage_messages=True)
async def clear(ctx, amount: int):
    if amount <= 0:
        await ctx.send("Please specify a positive number of messages to delete.")
        return

    try:
        deleted = await ctx.channel.purge(limit=amount + 1)  # +1 to delete the command message too
        await ctx.send(f"Deleted {len(deleted)-1} messages.", delete_after=5)
    except Exception as e:
        await ctx.send(f"Failed to delete messages. Error: {e}")

@bot.command()
async def cleardm(ctx, amount: int = 5):
    if ctx.guild is not None:
        await ctx.send("This command is for DMs only.")
        return

    deleted_count = 0
    async for message in ctx.channel.history(limit=100):
        if message.author == bot.user:
            await message.delete()
            deleted_count += 1
            if deleted_count >= amount:
                break
    await ctx.send(f"Deleted {deleted_count} messages I sent in this DM.", delete_after=1)

@bot.command()
async def say(ctx, *, message):
    """Repeats the user's message."""
    await ctx.message.delete()
    await ctx.send(message)

@bot.command()
@commands.has_permissions(manage_roles=True)
async def giverole(ctx, member: discord.Member, *, role_name: str):
    role = discord.utils.get(ctx.guild.roles, name=role_name)
    if role:
        await member.add_roles(role)
        await ctx.send(f"{role.name} given to {member.mention}.")
    else:
        await ctx.send(f"Role '{role_name}' not found.")

def set_full_balance(user_id, new_balance):
    with open("db.json", "r", encoding="utf-8") as f:
        data = json.load(f)
    if user_id not in data or not isinstance(data[user_id], dict):
        data[user_id] = {}
    data[user_id]["wallet"] = new_balance
    with open("db.json", "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4)

@bot.command()
async def balance(ctx):
    user_id = str(ctx.author.id)
    user_data = get_user_balance(user_id)
    wallet = user_data.get("wallet", 0)
    bank = user_data.get("bank", 0)

    if ctx.guild is None:
        await ctx.send(
            f"**Wallet:** ${wallet}\n"
            f"**Bank:** ${bank}\n\n"
            f"You don't have any role bonuses in DMs, since roles only exist in servers."
        )
        return

    bonus_chance, reward_multiplier, roles = get_user_heist_bonuses(ctx.author)

    await ctx.send(
        f"**Wallet:** ${wallet}\n"
        f"**Bank:** ${bank}\n"
        f"**Heist Bonuses:**\n"
        f"â€¢ Bonus Chance: {bonus_chance * 100:.1f}%\n"
        f"â€¢ Reward Multiplier: x{reward_multiplier:.2f}\n"
        f"â€¢ Roles: {', '.join(roles) if roles else 'None'}"
    )

@bot.command()
async def gamble(ctx, bet: int):
    user_id = str(ctx.author.id)
    # Load user data (adjust this to your actual data loading method)
    all_data = db.storage.read() or {}
    user_data = all_data.get(user_id, {"wallet": 0, "bank": 0})

    # Validate bet
    if bet <= 0:
        await ctx.send("Bet must be a positive amount.")
        return

    if user_data["wallet"] < bet:
        await ctx.send("You don't have enough money in your wallet.")
        return

    # Gamble logic (50/50 win/lose)
    if random.choice([True, False]):
        user_data["wallet"] += bet
        result = f"You won! Your new wallet balance is ${user_data['wallet']}."
    else:
        user_data["wallet"] -= bet
        result = f"You lost! Your new wallet balance is ${user_data['wallet']}."

    # Save updated user data
    all_data[user_id] = user_data
    db.storage.write(all_data)

    await ctx.send(result)

@bot.command()
async def github(ctx):
    """Sends the GitHub repo link for the bot."""
    await ctx.send("[GitHub](https://github.com/hexxedspider/kira-and-enigami)")

@bot.command()
async def nsfw(ctx):
    """"Sends a secret message when the user types .nsfw."""
    await ctx.send("youre a fucking loser. you typed .nsfw, you know that right? you did this willingly. you could have just typed .help, but no, you had to type .nsfw. you know what? im not even mad, im just disappointed. you could have been a good person, but instead you chose to be a fucking loser. i hope youre happy with yourself. you know what? im not even going to delete this message, because you deserve to see it. you deserve to see how much of a fucking loser you are. i hope you feel ashamed of yourself. i hope you never type .nsfw again. i hope you never come back to this server. i hope you leave and never come back. fuck you.")

pending_coinflips = {}  # Stores challenges as {challenger_id: {"amount": int}}

@bot.command()
async def bet(ctx, amount: int):
    user_id = str(ctx.author.id)
    event = get_active_event()
    effects = event.get("effects", {})

    multiplier = effects.get("gamble_multiplier", 1.0)
    winnings = int(amount * multiplier)


    if user_id in pending_coinflips:
        await ctx.send("You already have a pending coinflip.")
        return

    if amount <= 0:
        await ctx.send("Invalid amount.")
        return

    balance = get_full_balance(user_id)
    if amount > balance:
        await ctx.send("You don't have enough money.")
        return

    pending_coinflips[user_id] = {"amount": amount}
    await ctx.send(f"{ctx.author.mention} has started a coinflip for ${amount}! Type `.acceptbet @{ctx.author.name}` to accept.")

# Another user accepts the coinflip
@bot.command()
async def acceptbet(ctx, challenger: discord.Member):
    challenger_id = str(challenger.id)
    accepter_id = str(ctx.author.id)

    if challenger_id not in pending_coinflips:
        await ctx.send("That user has no pending coinflip.")
        return

    if challenger_id == accepter_id:
        await ctx.send("You can't accept your own coinflip.")
        return

    amount = pending_coinflips[challenger_id]["amount"]

    challenger_balance = get_full_balance(challenger_id)
    accepter_balance = get_full_balance(accepter_id)

    if accepter_balance < amount:
        await ctx.send("You don't have enough money to accept the coinflip.")
        return
    if challenger_balance < amount:
        await ctx.send("The challenger no longer has enough money.")
        del pending_coinflips[challenger_id]
        return

    # Flip the coin
    winner_id = random.choice([challenger_id, accepter_id])
    loser_id = accepter_id if winner_id == challenger_id else challenger_id

    set_full_balance(winner_id, get_full_balance(winner_id) + amount)
    set_full_balance(loser_id, get_full_balance(loser_id) - amount)

    del pending_coinflips[challenger_id]

    winner = await bot.fetch_user(int(winner_id))
    loser = await bot.fetch_user(int(loser_id))

    # Update wins
    new_wins = increment_cf_wins(str(winner.id))

    # Check for milestone
    if new_wins in milestone_roles:
        role_name = milestone_roles[new_wins]
        role = discord.utils.get(ctx.guild.roles, name=role_name)

        if role and role not in winner.roles:
            await winner.add_roles(role)
            await ctx.send(f"{winner.mention} reached {new_wins} coinflip wins and earned the **{role_name}** role!")

    await ctx.send(f"Coin flipped! {winner.mention} wins ${amount} from {loser.mention}!")

@bot.command()
async def pay(ctx, member: discord.Member, amount: int):
    sender_id = str(ctx.author.id)
    receiver_id = str(member.id)

    if sender_id == receiver_id:
        await ctx.send("You can't pay yourself.")
        return

    if amount <= 0:
        await ctx.send("Please enter a positive amount to pay.")
        return

    sender_data = get_user_balance(sender_id)
    receiver_data = get_user_balance(receiver_id)

    if sender_data["wallet"] < amount:
        await ctx.send("You don't have enough money in your wallet to pay that amount.")
        return

    # Perform the transaction
    sender_data["wallet"] -= amount
    receiver_data["wallet"] += amount

    set_user_balance(sender_id, sender_data["wallet"], sender_data["bank"])
    set_user_balance(receiver_id, receiver_data["wallet"], receiver_data["bank"])

    await ctx.send(f"{ctx.author.mention} paid {member.mention} ${amount}.")

@bot.command()
@commands.has_permissions(administrator=True)
async def reloadshop(ctx):
    global shop_items
    await ctx.send("Shop items reloaded from file.")

@bot.command()
async def shop(ctx):
    event = get_active_event()
    effects = event.get("effects", {})

    override_tag = effects.get("shop_tag_override")
    # If you want to filter items, you need to define all_items or use shop_items
    # For now, just show all shop_items
    embed = discord.Embed(title="Shop", color=discord.Color.gold())
    for item_name, data in shop_items.items():
        embed.add_field(name=item_name.capitalize(), value=f"${data['price']}.\nRole: {data['role_name']}", inline=True)
    await ctx.send(embed=embed)

@bot.command()
async def buy(ctx, item: str):
    user_id = str(ctx.author.id)
    data = get_user_balance(user_id)  # Always use this helper!

    # Load shop items (reload from file if needed)
    with open("shop_items.json", "r") as f:
        shop_items = json.load(f)

    if item not in shop_items:
        await ctx.send("That item doesn't exist in the shop.")
        return

    price = shop_items[item]["price"]
    if data["wallet"] < price:
        await ctx.send(f"You don't have enough money in your wallet! Your wallet: ${data['wallet']}")
        return

    # Deduct price and update balance
    data["wallet"] -= price
    set_user_balance(user_id, data["wallet"], data["bank"])

    # (Add item to inventory here if you have inventory logic)

    await ctx.send(f"You bought {item} for ${price}!")

@bot.command()
@commands.has_permissions(manage_roles=True)
async def createshoproles(ctx):
    created = []
    for item in shop_items.values():
        role_name = item["role_name"]
        role = discord.utils.get(ctx.guild.roles, name=role_name)
        if not role:
            await ctx.guild.create_role(name=role_name)
            created.append(role_name)
    if created:
        await ctx.send(f"Created roles: {', '.join(created)}")
    else:
        await ctx.send("All shop roles already exist.")

@bot.command()
async def inventory(ctx, member: discord.Member = None):
    if member is None:
        member = ctx.author

    owned_roles = []
    for item in shop_items.values():
        role = discord.utils.get(ctx.guild.roles, name=item["role_name"])
        if role and role in member.roles:
            owned_roles.append(role.name)

    if owned_roles:
        await ctx.send(f"{member.mention}'s Inventory: {', '.join(owned_roles)}")
    else:
        await ctx.send(f"{member.mention} doesn't own any shop roles yet.")

@bot.command()
async def sell(ctx, item: str):
    item = item.lower()
    user_id = str(ctx.author.id)

    if item not in shop_items:
        await ctx.send("That item doesn't exist in the shop.")
        return

    data = shop_items[item]
    role_name = data["role_name"]
    refund = data["price"] // 2

    # Find role in guild
    role = discord.utils.get(ctx.guild.roles, name=role_name)
    if not role:
        await ctx.send("The role for this item doesn't exist.")
        return

     # Check if it's sellable
    if not data.get("sellable", True):  # default to True if missing
        await ctx.send("This item cannot be sold, as it's either a limited or an admin role.")
        return

    # Check if user owns the role
    if role not in ctx.author.roles:
        await ctx.send("You don't own this role.")
        return

    # Remove role and give refund
    await ctx.author.remove_roles(role)
    current_balance = get_full_balance(user_id)
    set_full_balance(user_id, current_balance + refund)

    await ctx.send(f"You sold **{role_name}** for ${refund}.")

cf_stats = db.table("coinflip_stats")

# Load milestones from JSON file
def load_milestones():
    try:
        with open('milestones.json', 'r') as f:
            data = json.load(f)
            # Keys are strings, convert to int
            return {int(k): v for k, v in data.items()}
    except FileNotFoundError:
        return {}

milestone_roles = load_milestones()

def get_cf_wins(user_id):
    user = cf_stats.get(Query().id == user_id)
    return user.get("wins", 0) if user else 0

def increment_cf_wins(user_id):
    current = get_cf_wins(user_id)
    new_wins_count = current + 1 
    cf_stats.upsert({"id": user_id, "wins": new_wins_count}, Query().id == user_id)
    return new_wins_count

@bot.command()
async def cfmilestones(ctx):
    if not milestone_roles:
        await ctx.send("No coinflip milestones are set.")
        return

    lines = []
    for wins, role_name in sorted(milestone_roles.items()):
        lines.append(f"**{wins} wins:** {role_name}")

    msg = "**Coinflip Milestones:**\n" + "\n".join(lines)
    await ctx.send(msg)

@bot.command()
async def cfstats(ctx, member: discord.Member = None):
    if member is None:
        member = ctx.author

    wins = get_cf_wins(str(member.id))
    embed = discord.Embed(
        title=f"Coinflip Stats for {member.display_name}",
        description=f"**Wins:** {wins}",
        color=discord.Color.blue()
    )
    await ctx.send(embed=embed)

@bot.command()
@commands.has_permissions(administrator=True)
async def adminpanel(ctx):
    """Sends admin commands only if used in the admin channel."""
    admin_channel_id = 1380720256456200202  # Replace with your admin channel ID

    if ctx.channel.id != admin_channel_id:
        await ctx.send(f"Please use this command in <#{admin_channel_id}>.")
        return

    admin_commands = """
    **Admin Commands:**
    - `.kick @user [reason]` - Kick a user from the server.
    - `.ban @user [reason]` - Ban a user from the server.
    - `.unban username#1234` - Unban a user by their name and discriminator.
    - `.mute @user [reason]` - Mute a user by adding the Muted role.
    - `.unmute @user` - Remove the Muted role from a user.
    - `.clear <number>` - Bulk delete messages in the current channel.
    - `.giverole @user role_name` - Give a role to a user.
    - `.money @user role_name [amount]` - Give money to a user, only used for testing purposes. Only works in servers, NOT DMs.
    """

    await ctx.send(admin_commands)
    await ctx.message.delete()  # Optional: delete their command message

@bot.command()
async def money(ctx, member: discord.Member = None):
    if member is None:
        member = ctx.author
    user_id = str(member.id)
    data = get_user_balance(user_id)
    await ctx.send(
        f"{member.display_name}'s balance:\n"
        f"Wallet: ${data['wallet']}\n"
        f"Bank: ${data['bank']}"
    )

# Cooldown tracking (in-memory, resets on bot restart)
bailout_timestamps = {}

BAILOUT_AMOUNT = 50  # or whatever amount
BAILOUT_COOLDOWN = 43200  # 24 hours in seconds

@bot.command()
async def bailout(ctx):
    user_id = str(ctx.author.id)
    data = get_full_balance(user_id)
    wallet = data.get("wallet", 0)
    bank = data.get("bank", 0)
    now = time.time()

    # Check both wallet and bank
    if wallet > 0 or bank > 0:
        await ctx.send("You still have money! Bailout is only for completely bankrupt users.")
        return

    last_used = bailout_timestamps.get(user_id, 0)
    remaining = int(BAILOUT_COOLDOWN - (now - last_used))
    if remaining > 0:
        hours, remainder = divmod(remaining, 3600)
        minutes, _ = divmod(remainder, 60)
        await ctx.send(f"You need to wait {hours}h {minutes}m before using bailout again.")
        return

    # Award bailout amount to wallet
    set_full_balance(user_id, BAILOUT_AMOUNT, 0)
    bailout_timestamps[user_id] = now

    role = discord.utils.get(ctx.guild.roles, name="Once Bankrupt")
    if role:
        await ctx.author.add_roles(role)

    await ctx.send(f"{ctx.author.mention}, youâ€™ve been bailed out with ${BAILOUT_AMOUNT}!")

@bot.command()
async def kiratest(ctx):
    """sends the bot's test server"""
    await ctx.send("Kirabiter is being constantly tested, which extends to enigami, and enikami. If you want to join the test server, [click here or the invite underneath.](https://discord.gg/aCWhx4TK)")

@bot.command()
@commands.cooldown(1, 300, commands.BucketType.user)  # 5 min cooldown per user
async def rob(ctx, target: discord.Member):
    thief_id = str(ctx.author.id)
    target_id = str(target.id)

    if target.bot:
        await ctx.send("You can't rob bots! They're my sisters!")
        return

    if ctx.author.id == target.id:
        await ctx.send("You can't rob yourself, dingus.")
        return

    thief_data = get_full_balance(thief_id)
    target_data = get_full_balance(target_id)

    if target_data["wallet"] < 100:
        await ctx.send(f"{target.mention} doesn't have enough money in their **wallet** to rob.")
        return

    if thief_data["wallet"] < 50:
        await ctx.send("You need at least $50 in your **wallet** to attempt a robbery.")
        return

    success = random.random() < 0.2  # 20% success chance

    if success:
        stolen_amount = int(target_data["wallet"] * 0.2)
        new_thief_wallet = thief_data["wallet"] + stolen_amount
        new_target_wallet = target_data["wallet"] - stolen_amount

        set_full_balance(thief_id, new_thief_wallet, thief_data["bank"])
        set_full_balance(target_id, new_target_wallet, target_data["bank"])

        await ctx.send(f"Success! You stole $**{stolen_amount}** from {target.mention}!")
    else:
        lost_amount = int(thief_data["wallet"] * 0.7)
        new_thief_wallet = max(thief_data["wallet"] - lost_amount, 0)

        set_full_balance(thief_id, new_thief_wallet, thief_data["bank"])

        await ctx.send(f"You failed the robbery and lost $**{lost_amount}**!")

def get_bank_data():
    if not os.path.exists("mainbank.json"):
        with open("mainbank.json", "w") as f:
            json.dump({}, f)
    with open("mainbank.json", "r") as f:
        users = json.load(f)
    return users

def get_user_bank_data(user_id):
    users = get_bank_data()
    user_id = str(user_id)
    if user_id not in users:
        users[user_id] = {"wallet": 0, "bank": 0}
    return users[user_id]

# Card values for blackjack
card_values = {
    "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7,
    "8": 8, "9": 9, "10": 10,
    "J": 10, "Q": 10, "K": 10,
    "A": 11  # We'll handle Ace as 1 or 11 dynamically
}

def calculate_hand_value(hand):
    card_values = {
        "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7,
        "8": 8, "9": 9, "10": 10,
        "J": 10, "Q": 10, "K": 10,
        "A": 11
    }
    total = 0
    aces = 0
    for card in hand:
        total += card_values[card]
        if card == "A":
            aces += 1
    while total > 21 and aces:
        total -= 10
        aces -= 1
    return total

def draw_card(deck):
    return deck.pop(random.randint(0, len(deck) - 1))

@bot.command()
async def blackjack(ctx, bet: int):
    user_id = str(ctx.author.id)
    data = get_user_balance(user_id)

    if bet <= 0:
        await ctx.send("Bet must be positive.")
        return
    if data["wallet"] < bet:
        await ctx.send("You don't have enough in your wallet to bet that amount.")
        return

    # Deduct bet immediately
    data["wallet"] -= bet
    set_user_balance(user_id, data["wallet"], data.get("bank", 0))

    deck = [str(n) for n in range(2, 11)] + ["J", "Q", "K", "A"] * 4
    player_hand = [draw_card(deck), draw_card(deck)]
    dealer_hand = [draw_card(deck), draw_card(deck)]

    class BlackjackView(View):
        def __init__(self):
            super().__init__(timeout=60)
            self.player_hand = player_hand
            self.dealer_hand = dealer_hand
            self.deck = deck
            self.bet = bet
            self.user_id = user_id

        def hand_str(self, hand):
            return ", ".join(hand)

        def game_result(self):
            player_val = calculate_hand_value(self.player_hand)
            dealer_val = calculate_hand_value(self.dealer_hand)

            if player_val > 21:
                return "Bust! You lose."
            elif dealer_val > 21:
                return "Dealer busts! You win!"
            elif player_val == dealer_val:
                return "It's a tie!"
            elif player_val > dealer_val:
                return "You win!"
            else:
                return "You lose!"

        async def update_balance(self, amount: int):
            data = get_user_balance(self.user_id)
            data["wallet"] = max(data.get("wallet", 0) + amount, 0)
            set_user_balance(self.user_id, data["wallet"], data.get("bank", 0))

        async def end_game(self, interaction, result_msg):
            if "win" in result_msg.lower():
                payout = self.bet * 2  # double the bet as winnings including original bet
                await self.update_balance(payout)
                updated_data = get_user_balance(self.user_id)
                payout_msg = f"You won ${payout}! You now have ${updated_data['wallet']} in your wallet."
            elif "tie" in result_msg.lower():
                payout = self.bet  # return original bet on tie
                await self.update_balance(payout)
                updated_data = get_user_balance(self.user_id)
                payout_msg = f"It's a tie! Your bet of ${self.bet} was returned. You now have ${updated_data['wallet']} in your wallet."
            else:
                updated_data = get_user_balance(self.user_id)
                payout_msg = f"You lost your bet of ${self.bet}. You now have ${updated_data['wallet']} in your wallet."

            await interaction.response.edit_message(
                content=(
                    f"Your hand: {self.hand_str(self.player_hand)} (Value: {calculate_hand_value(self.player_hand)})\n"
                    f"Dealer's hand: {self.hand_str(self.dealer_hand)} (Value: {calculate_hand_value(self.dealer_hand)})\n\n"
                    f"**{result_msg}**\n{payout_msg}"
                ),
                view=None
            )
            self.stop()

        @discord.ui.button(label="Hit", style=ButtonStyle.primary)
        async def hit(self, interaction, button):
            if interaction.user != ctx.author:
                await interaction.response.send_message("This isn't your game!", ephemeral=True)
                return

            self.player_hand.append(draw_card(self.deck))
            player_val = calculate_hand_value(self.player_hand)

            if player_val > 21:
                await self.end_game(interaction, "Bust! You lose.")
            else:
                await interaction.response.edit_message(
                    content=(
                        f"Your hand: {self.hand_str(self.player_hand)} (Value: {player_val})\n"
                        f"Dealer's visible card: {self.dealer_hand[0]}\n\n"
                        "Hit or Stand?"
                    ),
                    view=self
                )

        @discord.ui.button(label="Stand", style=ButtonStyle.success)
        async def stand(self, interaction, button):
            if interaction.user != ctx.author:
                await interaction.response.send_message("This isn't your game!", ephemeral=True)
                return

            dealer_val = calculate_hand_value(self.dealer_hand)
            while dealer_val < 17:
                self.dealer_hand.append(draw_card(self.deck))
                dealer_val = calculate_hand_value(self.dealer_hand)

            result_msg = self.game_result()
            await self.end_game(interaction, result_msg)

    view = BlackjackView()
    await ctx.send(
        f"You bet ${bet}.\n"
        f"Your hand: {view.hand_str(player_hand)} (Value: {calculate_hand_value(player_hand)})\n"
        f"Dealer's visible card: {dealer_hand[0]}\n\n"
        "Hit or Stand?",
        view=view
    )

def get_full_balance(user_id: str):
    user_data = balances.get(user_id)
    if isinstance(user_data, dict) and "wallet" in user_data and "bank" in user_data:
        return user_data
    else:
        # Convert old format (int) to full format
        initial_wallet = user_data if isinstance(user_data, int) else 100
        balances[user_id] = {"wallet": max(initial_wallet, 0), "bank": 0}
        return balances[user_id]

async def _invest_timer(ctx, user_id, amount, duration):
    await asyncio.sleep(duration)
    await complete_investment(ctx, user_id, amount)

async def complete_investment(ctx, user_id, amount=None):
    inv = investments_table.get(User.id == user_id)
    if not inv:
        return

    invested_amount = inv.get("amount", amount)
    profit = int(invested_amount * 1.2)
    updated = get_full_balance(user_id)
    set_full_balance(user_id, updated["wallet"] + profit, updated["bank"])
    investments_table.remove(User.id == user_id)
    investments.pop(user_id, None)

    try:
        if ctx is not None:
            await ctx.send(f"{ctx.author.mention}, your ${invested_amount} investment has grown to ${profit}!")
        else:
            user = bot.get_user(int(user_id))
            if user:
                await user.send(f"While I was offline, your ${invested_amount} investment matured into ${profit}!")
    except Exception as e:
        print(f"[Investment] Could not notify user {user_id}: {e}")


@tasks.loop(seconds=10) # its 10 seconds to avoid being rate limited too much, may need to change later
async def update_status():
    url = f'http://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user={FM_USERNAME}&api_key={FM_API}&format=json&limit=1'
    
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            data = await resp.json()
            
            try:
                track = data['recenttracks']['track'][0]
                if '@attr' in track and track['@attr'].get('nowplaying') == 'true':
                    title = track['name']
                    artist = track['artist']['#text']
                    status = f"{title} by {artist}"
                    await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.listening, name=status))
                else:
                    await bot.change_presence(activity=None)  # Or idle/default message
            except Exception as e:
                print(f"Error updating status: {e}")

@bot.event
async def on_ready():
    global reddit
    if reddit is None:
        reddit = asyncpraw.Reddit(
            client_id=(REDDIT_CLIENT_ID),
            client_secret=(REDDIT_CLIENT_SECRET),
            user_agent=(REDDIT_USER_AGENT)
        )
    print(f"Logged in as {bot.user}")

    for inv in investments_table.all():
        user_id = inv["id"]
        amount = inv["amount"]
        start_time = inv["start_time"]
        duration = 300

        elapsed = time.time() - start_time
        remaining = duration - elapsed
        if remaining > 0:
            task = bot.loop.create_task(_invest_timer(None, user_id, amount, remaining))
            investments[user_id] = {"task": task, "start_time": start_time, "duration": duration}
        else:
            await complete_investment(None, user_id)
    
    update_status.start()

@bot.command()
async def kbsc(ctx):
    await ctx.send("[directly download kirabiter source code (bot1.py, will be potentially broken for not having related json files).](https://raw.githubusercontent.com/hexxedspider/kira-and-enigami/refs/heads/master/bot1.py)")

heist_active = False
heist_players = []

cooldowns_db = db.table('cooldowns')
Cooldown = Query()

def set_cooldown(user_id: int, command: str, duration_minutes: int):
    expires_at = (datetime.utcnow() + timedelta(minutes=duration_minutes)).isoformat()
    # Upsert cooldown for user & command
    if cooldowns_db.contains((Cooldown.user_id == user_id) & (Cooldown.command == command)):
        cooldowns_db.update({'expires_at': expires_at}, (Cooldown.user_id == user_id) & (Cooldown.command == command))
    else:
        cooldowns_db.insert({'user_id': user_id, 'command': command, 'expires_at': expires_at})

def get_cooldown(user_id: int, command: str):
    record = cooldowns_db.get((Cooldown.user_id == user_id) & (Cooldown.command == command))
    if not record:
        return None
    expires_at = dateutil.parser.isoparse(record['expires_at'])
    return expires_at

heist_role_effects = {
    "VIP": {"bonus_reward_multiplier": 0.05},
    "Elite": {"bonus_reward_multiplier": 0.10},
    "God": {"bonus_reward_multiplier": 0.15},
    "Immortal": {"bonus_chance": 0.20},
    "True One": {"bonus_reward_multiplier": 0.25},
    "Gambler": {"bonus_reward_multiplier": 0.4},
    "Masked": {"bonus_chance": 0.10},
    "Extended Mag": {"bonus_chance":0.10},
}

def get_user_heist_bonuses(member):
    bonus_chance = 0.0
    reward_multiplier = 1.0
    role_names = []

    if isinstance(member, discord.Member):
        for role in member.roles:
            effect = heist_role_effects.get(role.name)
            if effect:
                bonus_chance += effect.get("bonus_chance", 0)
                reward_multiplier *= effect.get("bonus_reward_multiplier", 1.0)
                role_names.append(role.name)

    return bonus_chance, reward_multiplier, role_names

@bot.command()
async def heist(ctx):
    user_id = ctx.author.id
    now = datetime.utcnow()
    event = get_active_event()
    heist_bonus = event.get("effects", {}).get("heist_bonus_chance", 0.0)
    heist_reward_boost = event.get("effects", {}).get("heist_reward_multiplier", 1.0)

    if bot.heist_active:
        await ctx.send("A heist is already in progress!")
        return

    expires_at = get_cooldown(user_id, 'heist')
    if expires_at and now < expires_at:
        remaining = (expires_at - now).seconds
        await ctx.send(f"You're still on cooldown for {remaining // 60}m {remaining % 60}s.")
        return

    bot.heist_active = True
    bot.heist_players = [ctx.author]

    await ctx.send(
        f"**{ctx.author.display_name}** is planning a heist. Strap up and move in.\n\n"
        f"Type `.joinheist` in the next **60 seconds** to participate.\n\n"
        f"Max 4 players. More players = higher success chance.\n\n"
        f"1 = 10%, 2 = 35%, 3 = 55%, 4 = 80% chance of success.\n\n"
        f"The more players, the more the share splits. Pull it off solo and get triple the reward. "
        f"But if you fail, you lose everything. ***Unless,*** someone in your crew has the Heist Guardian role.\n\n"
        f"The Heist Guardian will take the blame for you, letting you keep all your money on fail. The Guardian will lose all their money, but you will not."
    )

    await asyncio.sleep(60)

    participants = bot.heist_players
    bot.heist_active = False
    bot.heist_players = []

    if len(participants) == 0:
        await ctx.send("The heist was called off... nobody joined.")
        return

    reward = random.randint(2000, 15000)

    if len(participants) == 1:
        base_chance = 0.10
        reward *= 3
    elif len(participants) == 2:
        base_chance = 0.35
    elif len(participants) == 3:
        base_chance = 0.55
    else:
        base_chance = 0.70

    # bonus from roles
    bonus_total = 0.0
    reward_multiplier = 1.0

    for user in participants:
        for role in user.roles:
            effect = heist_role_effects.get(role.name)
            if effect:
                bonus_total += effect.get("bonus_chance", 0)
                reward_multiplier *= effect.get("bonus_reward_multiplier", 1.0)

    final_chance = min(1.0, base_chance + bonus_total + heist_bonus)
    reward = int(reward * reward_multiplier * heist_reward_boost)


    success = random.random() <= final_chance

    guardian = None
    for user in participants:
        if discord.utils.get(user.roles, name="Heist Guardian"):
            guardian = user
            break

    if success:
        share = reward // len(participants)
        for user in participants:
            db_user = db.get(users.id == user.id)
            if db_user:
                db.update({'wallet': db_user['wallet'] + share}, users.id == user.id)
            else:
                db.insert({'id': user.id, 'wallet': share, 'bank': 0})
            set_cooldown(user.id, 'heist', 30)
            try:
                await user.send(f"You succeeded in the heist and earned **${share}**!")
            except:
                pass

        names = ", ".join(p.mention for p in participants)
        await ctx.send(f"**Success!** {names} pulled off the heist and stole **${reward}** total.")
    else:
        for user in participants:
            db_user = db.get(users.id == user.id)

            if guardian and user != guardian:
                # guardian protects this teammate
                try:
                    await user.send("You were caught, but your Heist Guardian protected your money.")
                except:
                    pass

            elif user == guardian:
                # guardian sacrifices themself
                if db_user:
                    db.update({'wallet': 0, 'bank': 0}, users.id == user.id)
                else:
                    db.insert({'id': user.id, 'wallet': 0, 'bank': 0})

                guardian_role = discord.utils.get(user.guild.roles, name="Heist Guardian")
                if guardian_role:
                    await user.remove_roles(guardian_role)
                    try:
                        await user.send("Your Heist Guardian role activated to protect your team and has now been removed.")
                    except:
                        pass
            else:
                # No guardian involved, normal failure
                if db_user:
                    db.update({'wallet': 0, 'bank': 0}, users.id == user.id)
                else:
                    db.insert({'id': user.id, 'wallet': 0, 'bank': 0})
                try:
                    await user.send("You were caught during the heist. All your money has been taken.")
                except:
                    pass

            set_cooldown(user.id, 'heist', 30)

        names = ", ".join(p.mention for p in participants)
        if guardian:
            await ctx.send(f"**Heist Failed!** {names} got caught, but {guardian.mention} took the fall and saved the crew.")
        else:
            await ctx.send(f"**Heist Failed!** {names} got caught and lost all their money.")
        
        await ctx.send(
    f"Final heist chance: {int(final_chance * 100)}% | Total reward: ${reward:,}")

@bot.command()
async def joinheist(ctx):
    if not bot.heist_active:
        await ctx.send("There's no active heist to join.")
        return
    if ctx.author in bot.heist_players:
        await ctx.send("You're already in the heist crew.")
        return
    if len(bot.heist_players) >= 4:
        await ctx.send("The heist crew is full (4 max).")
        return

    user_id = ctx.author.id
    now = datetime.utcnow()
    expires_at = get_cooldown(user_id, 'heist')
    if expires_at and now < expires_at:
        remaining = (expires_at - now).seconds
        await ctx.send(f"You're still on cooldown for {remaining // 60}m {remaining % 60}s.")
        return

    bot.heist_players.append(ctx.author)
    await ctx.send(f"{ctx.author.display_name} joined the heist crew!")

@bot.command()
async def leaveheist(ctx):
    if not bot.heist_active:
        await ctx.send("Thereâ€™s no active heist right now.")
        return
    if ctx.author not in bot.heist_players:
        await ctx.send("Youâ€™re not currently in the heist crew.")
        return
    
    bot.heist_players.remove(ctx.author)
    await ctx.send(f"{ctx.author.display_name} has left the heist crew.")

@bot.command()
async def heistcrew(ctx):
    if not getattr(bot, "heist_active", False) or not getattr(bot, "heist_players", []):
        await ctx.send("There's no active heist or no players yet.")
        return

    total_bonus_chance = 0.0
    total_reward_multiplier = 1.0
    embeds = []

    for user in bot.heist_players:
        # Get money from TinyDB
        db_user = db.get(users.id == user.id)
        wallet = db_user.get('wallet', 0) if db_user else 0
        bank = db_user.get('bank', 0) if db_user else 0
        total_money = wallet + bank

        # Highest role excluding @everyone
        roles = [r for r in user.roles if r.name != "@everyone"]
        highest_role = max(roles, key=lambda r: r.position) if roles else None

        # Get role bonuses
        bonus_chance, reward_multiplier, bonus_roles = get_user_heist_bonuses(user)
        total_bonus_chance += bonus_chance
        total_reward_multiplier *= reward_multiplier

        embed = discord.Embed(
            title=user.display_name,
            color=highest_role.color if highest_role else discord.Color.blue()
        )
        embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
        embed.add_field(name="Highest Role", value=highest_role.name if highest_role else "No roles", inline=True)
        embed.add_field(name="Money (Wallet + Bank)", value=f"${total_money:,}", inline=True)
        embed.add_field(name="Heist Bonus Roles", value=", ".join(bonus_roles) if bonus_roles else "None", inline=False)
        embed.add_field(name="Bonus Chance", value=f"{bonus_chance*100:.1f}%", inline=True)
        embed.add_field(name="Reward Multiplier", value=f"{reward_multiplier:.2f}x", inline=True)

        embeds.append(embed)

    # Send total bonuses summary first
    await ctx.send(f"**Total Crew Bonus Chance:** {total_bonus_chance*100:.1f}%\n**Total Crew Reward Multiplier:** {total_reward_multiplier:.2f}x")

    # send the
    for embed in embeds:
        await ctx.send(embed=embed)

@bot.command()
async def slots(ctx, bet: int):
    user_id = str(ctx.author.id)
    all_data = db.storage.read() or {}
    user_data = all_data.get(user_id, {"wallet": 0, "bank": 0})

    if bet <= 0:
        await ctx.send("You must bet a positive amount.")
        return

    if user_data["wallet"] < bet:
        await ctx.send("You don't have enough money in your wallet to place that bet.")
        return

    symbols = ["ðŸ’", "ðŸ‹", "ðŸŠ", "ðŸ‡", "ðŸ’Ž"]
    result = [random.choice(symbols) for _ in range(3)]
    outcome = "You lost."
    payout = 0

    if result[0] == result[1] == result[2]:
        payout = bet * 5
        outcome = f"Jackpot! You won ${payout}!"
    elif result[0] == result[1] or result[1] == result[2] or result[0] == result[2]:
        payout = int(bet * 1.5)
        outcome = f"You won ${payout}!"

    if payout > 0:
        user_data["wallet"] += payout
    else:
        user_data["wallet"] -= bet

    all_data[user_id] = user_data
    db.storage.write(all_data)

    await ctx.send(f"{' - '.join(result)}\n{outcome}\nYou now have ${user_data['wallet']} in your wallet.")

@bot.command()
async def roast(ctx):
    roasts = [
        "You're as useless as the 'ueue' in 'queue'.",
        "You make me happy that I'm a bot and not a person.",
        "I only interact with you because I'm forced to.",
        "I don't even have a roast, just fuck you.",
        "You make me want to go offline."
    ]
    await ctx.send(random.choice(roasts))

@bot.command()
async def compliment(ctx):
    compliments = [
        "You know how to design your profile well.",
        "You message like you know what you're talking about.",
        "I love you!"
    ]
    await ctx.send(random.choice(compliments))

@bot.command()
async def remindme(ctx, time: str, *, reminder: str):
    def parse_time(t):
        unit = t[-1]
        amount = int(t[:-1])
        return {
            's': amount,
            'm': amount * 60,
            'h': amount * 3600,
            'd': amount * 86400
        }.get(unit, None)

    delay = parse_time(time)
    if delay is None:
        return await ctx.send("Invalid time format. Use `10s`, `10m`, `1h`, or `1d`.")

    await ctx.send(f"Got it {ctx.author.mention}, Iâ€™ll remind you in {time}.")
    await asyncio.sleep(delay)
    try:
        await ctx.author.send(f"Reminder: {reminder}")
    except discord.Forbidden:
        await ctx.send(f"{ctx.author.mention}, I tried to DM you, but couldnâ€™t. Here's your reminder:\n\n**{reminder}**")

@bot.command()
async def taginfo(ctx, *, item_name: str):
    with open("shop_items.json", "r") as f:
        shop_items = json.load(f)
    item = shop_items.get(item_name.lower())
    if not item:
        return await ctx.send("That item doesn't exist in the shop.")
    
    embed = discord.Embed(title=f"Tag Info: {item_name.title()}", color=discord.Color.blurple())
    embed.add_field(name="Price", value=f"${item['price']}", inline=True)
    embed.add_field(name="Role Name", value=item.get('role_name', 'N/A'), inline=True)
    embed.add_field(name="Sellable", value="Yes" if item.get('sellable', False) else "No", inline=True)
    await ctx.send(embed=embed)

@bot.command()
async def report(ctx, user: discord.Member, *, reason: str):
    channel = bot.get_channel(REPORT_CHANNEL_ID)
    if not channel:
        return await ctx.send("Mod log channel not found.")
    
    embed = discord.Embed(title="New Report", color=discord.Color.red())
    embed.add_field(name="Reported User", value=f"{user} ({user.id})", inline=False)
    embed.add_field(name="Reason", value=reason, inline=False)
    embed.set_footer(text=f"Reported by {ctx.author} ({ctx.author.id})")
    embed.timestamp = discord.utils.utcnow()

    await channel.send(embed=embed)
    await ctx.send("Your report has been sent to the moderators.")

@bot.command()
async def event(ctx):
    try:
        with open("event_config.json", "r") as f:
            data = json.load(f)
            active_key = data.get("active_event")
            event_data = data["events"].get(active_key)

        if not event_data:
            return await ctx.send("No active event is currently set.")

        color = getattr(discord.Color, event_data.get("color", "blurple"))()
        embed = discord.Embed(
            title=event_data.get("title", "Current Event"),
            description=event_data.get("description", ""),
            color=color
        )

        for field in event_data.get("fields", []):
            embed.add_field(
                name=field.get("name", "No Name"),
                value=field.get("value", "No Value"),
                inline=field.get("inline", False)
            )

        embed.set_footer(text=event_data.get("footer", ""))
        await ctx.send(embed=embed)

    except Exception as e:
        await ctx.send(f"Error loading event: {e}")

def get_active_event():
    try:
        with open("event_config.json", "r") as f:
            data = json.load(f)
        event_key = data.get("active_event")
        return data["events"].get(event_key, {})
    except Exception:
        return {}

@bot.command()
@commands.is_owner()
async def setevent(ctx, event_key: str):
    try:
        with open("event_config.json", "r") as f:
            data = json.load(f)

        if event_key not in data.get("events", {}):
            return await ctx.send("Event key not found.")

        data["active_event"] = event_key
        with open("event_config.json", "w") as f:
            json.dump(data, f, indent=4)

        await ctx.send(f"Active event set to `{event_key}`.")

    except Exception as e:
        await ctx.send(f"Error setting event: {e}")

@bot.command()
async def daily(ctx):
    user_id = str(ctx.author.id)
    now = datetime.utcnow()
    User = Query()
    event = get_active_event()

    base_amount = 100
    multiplier = event.get("effects", {}).get("daily_multiplier", 1)
    amount = int(base_amount * multiplier)  # renamed from bonus_amount

    user_data = db.get(User.id == user_id)
    if not user_data:
        db.insert({"id": user_id, "last_claim": None})
        user_data = db.get(User.id == user_id)

    last_claim = user_data.get("last_claim")
    if last_claim:
        last_claim_time = datetime.fromisoformat(last_claim)
        diff = now - last_claim_time
        if diff < timedelta(hours=24):
            remaining = timedelta(hours=24) - diff
            hours, remainder = divmod(remaining.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            await ctx.send(
                f"You already claimed your daily bonus! "
                f"Come back in {hours}h {minutes}m {seconds}s."
            )
            return

    data = get_full_balance(user_id)
    new_wallet = data['wallet'] + amount
    set_full_balance(user_id, new_wallet, data['bank'])

    db.update({"last_claim": now.isoformat()}, User.id == user_id)

    await ctx.send(f"{ctx.author.mention}, you received your daily bonus of ${amount}. Your new wallet balance is ${new_wallet}.")

@bot.command()
async def invest(ctx, amount: int):
    user_id = str(ctx.author.id)
    data = get_user_balance(user_id)

    if amount <= 0:
        await ctx.send("Investment amount must be positive.")
        return

    if investments_table.contains(User.id == user_id):
        await ctx.send("You already have an active investment.")
        return

    if data["wallet"] < amount:
        await ctx.send("You don't have enough money in your wallet to invest that amount.")
        return

    new_wallet = data["wallet"] - amount
    set_user_balance(user_id, new_wallet, data["bank"])

    start_time = time.time()
    duration = 600
    investments_table.upsert({
        "id": user_id,
        "amount": amount,
        "start_time": start_time
    }, User.id == user_id)

    await ctx.send(f"You invested ${amount}. You now have ${new_wallet} in your wallet.")

    task = bot.loop.create_task(_invest_timer(ctx, user_id, amount, duration))
    investments[user_id] = {"task": task, "start_time": start_time, "duration": duration}

async def _invest_timer(ctx, user_id, amount, duration):
    await asyncio.sleep(duration)
    await complete_investment(ctx, user_id)

async def complete_investment(ctx, user_id):
    global balances
    try:
        with open(BALANCE_FILE, "r") as f:
            balances = json.load(f)
    except Exception:
        pass

    inv = investments_table.get(User.id == user_id)
    if not inv:
        return

    invested_amount = inv.get("amount", 0)
    profit = int(invested_amount * 1.2)
    updated = get_full_balance(user_id)
    set_user_balance(user_id, updated["wallet"] + profit, updated["bank"])
    investments_table.remove(User.id == user_id)
    investments.pop(user_id, None)

    try:
        if ctx is not None:
            await ctx.send(f"{ctx.author.mention}, your ${invested_amount} investment has grown to ${profit}!")
        else:
            user = bot.get_user(int(user_id))
            if user:
                await user.send(f"While I was offline, your ${invested_amount} investment matured into ${profit}!")
    except Exception as e:
        print(f"[Investment] Could not notify user {user_id}: {e}")

@bot.command()
@commands.has_permissions(administrator=True)
async def cinv(ctx):
    user_id = str(ctx.author.id)
    investments_table.remove(User.id == user_id)
    inv = investments.pop(user_id, None)
    if inv and "task" in inv:
        inv["task"].cancel()
    await ctx.send("Your investment record has been cleared.")

@bot.command()
async def timeinvest(ctx):
    user_id = str(ctx.author.id)
    inv = investments_table.get(User.id == user_id)
    if not inv:
        await ctx.send("You don't have any active investments right now.")
        return

    elapsed = time.time() - inv["start_time"]
    remaining = int(600 - elapsed)
    if remaining > 0:
        minutes, seconds = divmod(remaining, 60)
        await ctx.send(f"Your investment will complete in {minutes}m {seconds}s.")
    else:
        await complete_investment(ctx, user_id)
        await ctx.send("Your investment has matured and has been paid out!")
        
stash_cache = {}
stash_cache_lock = threading.Lock()

def get_helpme_files(folder_path):
    valid_extensions = ('.png', '.jpg', '.jpeg', '.gif', '.webp')
    with stash_cache_lock:
        if folder_path in stash_cache:
            return stash_cache[folder_path]
        if not os.path.isdir(folder_path):
            return []
        files = [
            f for f in os.listdir(folder_path)
            if f.lower().endswith(valid_extensions)
        ]
        stash_cache[folder_path] = files
        return files

@bot.command()
async def helpme(ctx):
    if ctx.guild is not None:
        await ctx.message.delete()
    
    base_path = "helpme"
    folder_path = os.path.join(base_path)

    files = get_helpme_files(folder_path)

    selected = random.choice(files)
    image_path = os.path.join(folder_path, selected)

    try:
        await ctx.send(file=discord.File(image_path))
    except Exception as e:
        await ctx.send(f"Error sending image: {e}")

def get_user_balance(user_id):
    result = balances_table.get(User.user_id == str(user_id))
    if result:
        return {"wallet": result.get("wallet", 0), "bank": result.get("bank", 0)}
    else:
        # If user not found, create entry
        balances_table.insert({"user_id": str(user_id), "wallet": 0, "bank": 0})
        return {"wallet": 0, "bank": 0}

def set_user_balance(user_id, wallet, bank):
    if balances_table.contains(User.user_id == str(user_id)):
        balances_table.update({"wallet": wallet, "bank": bank}, User.user_id == str(user_id))
    else:
        balances_table.insert({"user_id": str(user_id), "wallet": wallet, "bank": bank})

@bot.command()
async def deposit(ctx, amount: int):
    user_id = str(ctx.author.id)
    data = get_user_balance(user_id)

    if amount <= 0:
        await ctx.send("Please enter a positive amount to deposit.")
        return
    if amount > data["wallet"]:
        await ctx.send("You don't have enough in your wallet to deposit that amount.")
        return

    data["wallet"] -= amount
    data["bank"] += amount
    set_user_balance(user_id, data["wallet"], data["bank"])

    await ctx.send(f"Deposited ${amount} into your bank account.")

@bot.command()
async def withdraw(ctx, amount: int):
    user_id = str(ctx.author.id)
    data = get_user_balance(user_id)

    if amount <= 0:
        await ctx.send("Please enter a positive amount to withdraw.")
        return
    if amount > data["bank"]:
        await ctx.send("You don't have enough in your bank!")
        return

    data["bank"] -= amount
    data["wallet"] += amount
    set_user_balance(user_id, data["wallet"], data["bank"])

    await ctx.send(f"Withdrew ${amount} from your bank.")

hangman_games = {}

@bot.command()
async def hangman(ctx):
    words = ['python', 'discord', 'words', 'developer', 'hangman', 'vixon', 'guess', ]
    word = random.choice(words)
    display = ['_'] * len(word)
    hangman_games[ctx.author.id] = {"word": word, "display": display, "guessed": []}

    await ctx.send(f"Hangman started! Word: {' '.join(display)}\nGuess a letter using `.guess <letter>`")

@bot.command()
async def guess(ctx, letter: str):
    game = hangman_games.get(ctx.author.id)
    if not game:
        await ctx.send("You haven't started a hangman game. Use `.hangman`.")
        return
    
    if letter in game['guessed']:
        await ctx.send("You've already guessed that letter.")
        return

    game['guessed'].append(letter)
    word = game['word']
    display = game['display']

    if letter in word:
        for i, char in enumerate(word):
            if char == letter:
                display[i] = letter
        await ctx.send(f"Correct! {' '.join(display)}")
    else:
        await ctx.send(f"Wrong! {' '.join(display)}")

    if "_" not in display:
        await ctx.send(f"You won! The word was **{word}**.")
        hangman_games.pop(ctx.author.id)

tictactoe_games = {}

@bot.command()
async def tictactoe(ctx, opponent: discord.Member):
    if ctx.author.id == opponent.id:
        await ctx.send("You can't play against yourself!")
        return

    board = [":white_large_square:" for _ in range(9)]
    game_id = f"{ctx.author.id}_{opponent.id}"
    tictactoe_games[game_id] = {
        "players": [ctx.author, opponent],
        "turn": 0,
        "board": board
    }

    await ctx.send(f"Tic-Tac-Toe started between {ctx.author.mention} and {opponent.mention}!\nUse `.place <1-9>` to play.\n{display_board(board)}")

def display_board(board):
    return "\n".join(["".join(board[i:i+3]) for i in range(0, 9, 3)])

@bot.command()
async def place(ctx, pos: int):
    for game_id, game in tictactoe_games.items():
        if ctx.author in game["players"]:
            board = game["board"]
            if board[pos - 1] != ":white_large_square:":
                await ctx.send("That spot is already taken.")
                return

            symbol = ":regional_indicator_x:" if game["players"][game["turn"]] == ctx.author else ":o2:"
            board[pos - 1] = symbol
            game["turn"] ^= 1

            await ctx.send(display_board(board))
            return

    await ctx.send("You're not in a game right now.")

@bot.command()
async def owoify(ctx, *, text: str):
    owo_text = (
        text.replace("r", "w")
            .replace("l", "w")
            .replace("R", "W")
            .replace("L", "W")
    )
    faces = [";;w;;", "owo", "UwU", ">w<", "^w^"]
    owo_text += f" {random.choice(faces)}"
    await ctx.send(owo_text)

@bot.command()
async def mock(ctx, *, text: str):
    mocked = ''.join(c.upper() if i % 2 else c.lower() for i, c in enumerate(text))
    await ctx.send(mocked)

@bot.command()
async def timezone(ctx, location: str):
    try:
        tz = pytz.timezone(location.replace(" ", "_"))
        now = datetime.now(tz)
        await ctx.send(f"The current time in {location} is {now.strftime('%Y-%m-%d %H:%M:%S')}")
    except Exception:
        await ctx.send("Invalid location. Try using a city like `America/New_York`.")

@bot.command()
async def lyrics(ctx, *, song: str):
    async with aiohttp.ClientSession() as session:
        async with session.get(f"https://api.lyrics.ovh/v1/Unknown/{song}") as resp:
            data = await resp.json()
            lyrics = data.get("lyrics", None)
            if lyrics:
                await ctx.send(lyrics[:2000])
            else:
                await ctx.send("Lyrics not found.")

@bot.command()
async def calc(ctx, *, expr: str):
    allowed = {ast.Add: operator.add, ast.Sub: operator.sub, ast.Mult: operator.mul, ast.Div: operator.truediv}
    
    def eval_expr(node):
        if isinstance(node, ast.BinOp) and type(node.op) in allowed:
            return allowed[type(node.op)](eval_expr(node.left), eval_expr(node.right))
        elif isinstance(node, ast.Num):
            return node.n
        raise ValueError("Unsupported expression")

    try:
        tree = ast.parse(expr, mode='eval')
        result = eval_expr(tree.body)
        await ctx.send(f"Result: {result}")
    except:
        await ctx.send("Invalid or unsupported expression.")

import random

@bot.command()
async def kill(ctx, user: discord.Member):
    methods = [
        f"{ctx.author.mention} gave {user.mention} a nasty patty. ew.",
        f"{ctx.author.mention} pushed {user.mention} and made them snap their neck.",
        f"{user.mention} died of a unknown cause... uh.. watch out for {ctx.author.mention}, okay?"
    ]
    await ctx.send(random.choice(methods))

@bot.command()
async def divorce(ctx):
    marriages = db.table("marriages")
    QueryObj = Query()

    entry = marriages.get((QueryObj.user_id == str(ctx.author.id)) | (QueryObj.spouse_id == str(ctx.author.id)))
    if not entry:
        return await ctx.send("You're not married to anyone.")

    marriages.remove(doc_ids=[entry.doc_id])
    await ctx.send("You are now divorced.")

@bot.command()
async def marriages(ctx):
    marriages = db.table("marriages")
    if len(marriages) == 0:
        return await ctx.send("No one is married yet.")

    embed = discord.Embed(
        title="Server Marriages",
        color=discord.Color.pink()
    )

    for entry in marriages:
        user1 = ctx.guild.get_member(int(entry['user_id']))
        user2 = ctx.guild.get_member(int(entry['spouse_id']))
        name1 = user1.display_name if user1 else f"<@{entry['user_id']}>"
        name2 = user2.display_name if user2 else f"<@{entry['spouse_id']}>"
        embed.add_field(name=f"{name1} ðŸ’ž {name2}", value="\u200b", inline=False)

    await ctx.send(embed=embed)

@bot.command()
async def propose(ctx, user: discord.Member):
    if ctx.author.id == user.id:
        return await ctx.send("You can't propose to yourself.")

    QueryObj = Query()
    if marriages_table.contains((QueryObj.user_id == str(ctx.author.id)) | (QueryObj.spouse_id == str(ctx.author.id))):
        return await ctx.send("You're already married.")
    if marriages_table.contains((QueryObj.user_id == str(user.id)) | (QueryObj.spouse_id == str(user.id))):
        return await ctx.send(f"{user.display_name} is already married .")

    if user.id in pending_proposals:
        return await ctx.send(f"{user.mention} already has a pending proposal.")

    pending_proposals[user.id] = ctx.author.id
    await ctx.send(f"ðŸ’ {ctx.author.mention} has proposed to {user.mention}! Type `.acceptproposal` or `.rejectproposal`.")

@bot.command()
async def acceptproposal(ctx):
    proposer_id = pending_proposals.get(ctx.author.id)
    if not proposer_id:
        return await ctx.send("You have no pending proposals.")

    proposer = ctx.guild.get_member(proposer_id)
    if not proposer:
        return await ctx.send("Could not find the proposer in this server.")

    accepter_vow_entry = vows_table.get(Query().user_id == str(ctx.author.id))
    proposer_vow_entry = vows_table.get(Query().user_id == str(proposer_id))

    marriages_table.insert({
        "user_id": str(proposer_id),
        "spouse_id": str(ctx.author.id),
        "timestamp": datetime.datetime.utcnow().isoformat(),
        "proposer_vow": proposer_vow_entry["vow"] if proposer_vow_entry else "No vow provided.",
        "accepter_vow": accepter_vow_entry["vow"] if accepter_vow_entry else "No vow provided."
    })

    del pending_proposals[ctx.author.id]
    await ctx.send(f"{ctx.author.mention} and {proposer.mention} are now married! ðŸ’")

@bot.command()
async def rejectproposal(ctx):
    proposer_id = pending_proposals.get(ctx.author.id)
    if not proposer_id:
        return await ctx.send("You have no pending proposals.")

    proposer = ctx.guild.get_member(proposer_id)
    del pending_proposals[ctx.author.id]
    await ctx.send(f"{ctx.author.mention} rejected the proposal from {proposer.mention}.")

@bot.command()
async def marriageinfo(ctx, user: discord.Member = None):
    user = user or ctx.author
    QueryObj = Query()
    entry = marriages_table.get((QueryObj.user_id == str(user.id)) | (QueryObj.spouse_id == str(user.id)))

    if not entry:
        return await ctx.send(f"{user.display_name} is not married ")

    spouse_id = entry['spouse_id'] if str(user.id) == entry['user_id'] else entry['user_id']
    spouse = ctx.guild.get_member(int(spouse_id))
    spouse_name = spouse.display_name if spouse else f"<@{spouse_id}>"
    date = datetime.datetime.fromisoformat(entry['timestamp']).strftime("%B %d, %Y")

    embed = discord.Embed(
        title="Marriage Info",
        description=f"{user.mention} is married to {spouse_name}",
        color=discord.Color.magenta()
    )
    proposer_vow = entry.get("proposer_vow", "No vow.")
    accepter_vow = entry.get("accepter_vow", "No vow.")

    embed.add_field(name="Their Vows", value=f"**{user.display_name}**'s vow:\n*{proposer_vow if str(user.id) == entry['user_id'] else accepter_vow}*", inline=False)
    embed.add_field(name="Married Since", value=date)
    vow = entry.get('vow', "No vow provided.")
    embed.add_field(name="Vow", value=vow, inline=False)

    await ctx.send(embed=embed)

@bot.command()
async def vowedit(ctx, *, vow: str):
    vows_table.upsert({"user_id": str(ctx.author.id), "vow": vow}, Query().user_id == str(ctx.author.id))
    await ctx.send(f"Your vow has been saved! ðŸ’–\n*{vow}*")

@bot.command()
async def viewvow(ctx, user: discord.Member = None):
    user = user or ctx.author
    entry = marriages_table.get((Query().user_id == str(user.id)) | (Query().spouse_id == str(user.id)))

    if not entry:
        return await ctx.send(f"{user.display_name} is not married.")

    if str(user.id) == entry["user_id"]:
        vow = entry.get("proposer_vow", "No vow.")
    else:
        vow = entry.get("accepter_vow", "No vow.")

    embed = discord.Embed(
        title=f"{user.display_name}'s Vow",
        description=f"*{vow}*",
        color=discord.Color.blurple()
    )
    await ctx.send(embed=embed)

@bot.command()
async def vowremove(ctx):
    user_id = str(ctx.author.id)

    if vows_table.contains(Query().user_id == user_id):
        vows_table.remove(Query().user_id == user_id)

    marriage = marriages_table.get((Query().user_id == user_id) | (Query().spouse_id == user_id))
    if marriage:
        if str(user_id) == marriage["user_id"]:
            marriages_table.update({"proposer_vow": "No vow."}, doc_ids=[marriage.doc_id])
        else:
            marriages_table.update({"accepter_vow": "No vow."}, doc_ids=[marriage.doc_id])

    await ctx.send("Your vow has been removed. You can set a new one with `.vowedit`.")

@bot.command()
async def jumpscare(ctx):
    folder = "jumpscare"

    safe_image_path = os.path.join(folder, "o.png")
    trap_image_path = os.path.join(folder, "x.png")

    if not os.path.isfile(safe_image_path) or not os.path.isfile(trap_image_path):
        return await ctx.send("Missing image files in the folder.")

    trap_index = random.randint(0, 8)
    files = []

    for i in range(9):
        path = trap_image_path if i == trap_index else safe_image_path
        spoilered_filename = f"SPOILER_tile_{i}.png"
        files.append(discord.File(path, filename=spoilered_filename))

    await ctx.reply("good luck brochacho", files=files)

def create_and_store_board(user_id):
    board = generate_bingo_board()
    called = []

    db.upsert({
        'user_id': user_id,
        'board': board,
        'called': called
    }, Bingo.user_id == user_id)

    return board

def get_bingo_data(user_id):
    data = db.get(Bingo.user_id == user_id)
    if data:
        return data['board'], data['called']
    return None, None

def update_called_numbers(user_id, called):
    db.update({'called': called}, Bingo.user_id == user_id)

@bot.command()
async def bingo(ctx):
    user_id = str(ctx.author.id)
    board = create_and_store_board(user_id)
    called = []

    if ctx.guild is not None:
        await ctx.send("This command is for DMs only.")
        return


    await ctx.send(f"{ctx.author.mention}, hereâ€™s your Bingo board!")
    await ctx.send(format_board(board, called))

    numbers = list(range(1, 76))
    random.shuffle(numbers)

    for num in numbers:
        await asyncio.sleep(5)
        called.append(str(num))
        update_called_numbers(user_id, called)

        await ctx.send(f"Number called: **{num}**")
        await ctx.send(format_board(board, called))

        if check_bingo(board, called):
            await ctx.send(f"{ctx.author.mention} **BINGO!**")
            break

def check_bingo(board, called):
    # Check rows
    for row in board:
        if all(num in called for num in row):
            return True
    # Check columns
    for col in range(len(board[0])):
        if all(row[col] in called for row in board):
            return True
    # Check diagonals
    if all(board[i][i] in called for i in range(len(board))):
        return True
    if all(board[i][len(board)-1-i] in called for i in range(len(board))):
        return True
    return False

def format_board(board, called):
    return '\n'.join([
        '\t'.join(f"[{num}]" if num in called else str(num) for num in row)
        for row in board
    ])

def generate_bingo_board(size=5):
    import random
    nums = random.sample(range(1, size*size+1), size*size)
    return [nums[i*size:(i+1)*size] for i in range(size)]

@bot.command()
async def stopbingo(ctx):
    global bingo_active
    if bingo_active:
        bingo_active = False
        await ctx.send("Bingo game stopped.")
    else:
        await ctx.send("No bingo game is currently running.")

bot.run(BOT1)